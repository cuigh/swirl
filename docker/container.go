package docker

import (
	"bytes"
	"context"
	"io"
	"strconv"
	"strings"

	"github.com/cuigh/swirl/misc"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
)

// ContainerList return containers on the host.
func (d *Docker) ContainerList(ctx context.Context, name, status string, pageIndex, pageSize int) (containers []types.Container, total int, err error) {
	err = d.call(func(c *client.Client) (err error) {
		opts := types.ContainerListOptions{Filters: filters.NewArgs()}
		if status == "" {
			opts.All = true
		} else {
			opts.Filters.Add("status", status)
		}
		if name != "" {
			opts.Filters.Add("name", name)
		}

		containers, err = c.ContainerList(ctx, opts)
		if err == nil {
			total = len(containers)
			start, end := misc.Page(total, pageIndex, pageSize)
			containers = containers[start:end]
		}
		return
	})
	return
}

// ContainerInspect return container raw information.
func (d *Docker) ContainerInspect(ctx context.Context, id string) (container types.ContainerJSON, raw []byte, err error) {
	var c *client.Client
	if c, err = d.client(); err == nil {
		container, raw, err = c.ContainerInspectWithRaw(ctx, id, true)
	}
	return
}

// ContainerRemove remove a container.
func (d *Docker) ContainerRemove(ctx context.Context, id string) error {
	return d.call(func(c *client.Client) (err error) {
		return c.ContainerRemove(ctx, id, types.ContainerRemoveOptions{})
	})
}

// ContainerExecCreate creates an exec instance.
func (d *Docker) ContainerExecCreate(ctx context.Context, id string, cmd string) (resp types.IDResponse, err error) {
	err = d.call(func(c *client.Client) (err error) {
		opts := types.ExecConfig{
			AttachStdin:  true,
			AttachStdout: true,
			AttachStderr: true,
			Tty:          true,
			//User: "root",
			Cmd: strings.Split(cmd, " "),
		}
		//c.DialSession()
		resp, err = c.ContainerExecCreate(ctx, id, opts)
		return
	})
	return
}

// ContainerExecAttach attaches a connection to an exec process in the server.
func (d *Docker) ContainerExecAttach(ctx context.Context, id string) (resp types.HijackedResponse, err error) {
	err = d.call(func(c *client.Client) (err error) {
		opts := types.ExecStartCheck{
			Detach: false,
			Tty:    true,
		}
		resp, err = c.ContainerExecAttach(ctx, id, opts)
		return err
	})
	return
}

// ContainerExecStart starts an exec instance.
func (d *Docker) ContainerExecStart(ctx context.Context, id string) error {
	return d.call(func(c *client.Client) (err error) {
		opts := types.ExecStartCheck{
			Detach: false,
			Tty:    true,
		}
		return c.ContainerExecStart(ctx, id, opts)
	})
}

// ContainerLogs returns the logs generated by a container.
func (d *Docker) ContainerLogs(ctx context.Context, id string, lines int, timestamps bool) (stdout, stderr *bytes.Buffer, err error) {
	err = d.call(func(c *client.Client) (err error) {
		var (
			rc   io.ReadCloser
			opts = types.ContainerLogsOptions{
				ShowStdout: true,
				ShowStderr: true,
				Tail:       strconv.Itoa(lines),
				Timestamps: timestamps,
				//Since: (time.Hour * 24).String()
			}
		)
		if rc, err = c.ContainerLogs(ctx, id, opts); err == nil {
			defer rc.Close()

			stdout = &bytes.Buffer{}
			stderr = &bytes.Buffer{}
			_, err = stdcopy.StdCopy(stdout, stderr, rc)
		}
		return
	})
	return
}
