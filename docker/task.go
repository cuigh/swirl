package docker

import (
	"bytes"
	"context"
	"io"
	"sort"
	"strconv"

	"github.com/cuigh/swirl/misc"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/swarm"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
)

// TaskList return all running tasks of a service or a node.
func (d *Docker) TaskList(ctx context.Context, node, service, state string, pageIndex, pageSize int) (tasks []swarm.Task, total int, err error) {
	err = d.call(func(c *client.Client) (err error) {
		args := filters.NewArgs()
		if service != "" {
			args.Add("service", service)
		}
		if state != "" {
			args.Add("desired-state", state)
		}
		if node != "" {
			args.Add("node", node)
		}
		//if name != "" {
		//	args.Add("name", name)
		//}

		tasks, err = c.TaskList(ctx, types.TaskListOptions{Filters: args})
		total = len(tasks)
		if err == nil && total > 0 {
			sort.Slice(tasks, func(i, j int) bool {
				return tasks[i].UpdatedAt.After(tasks[j].UpdatedAt)
			})
			start, end := misc.Page(total, pageIndex, pageSize)
			tasks = tasks[start:end]
		}
		return
	})
	return
}

// TaskInspect return detail information of a task.
func (d *Docker) TaskInspect(ctx context.Context, id string) (task swarm.Task, raw []byte, err error) {
	err = d.call(func(c *client.Client) (err error) {
		task, raw, err = c.TaskInspectWithRaw(ctx, id)
		return
	})
	return
}

// TaskLogs returns the logs generated by a task in an io.ReadCloser.
func (d *Docker) TaskLogs(ctx context.Context, id string, lines int, timestamps bool) (stdout, stderr *bytes.Buffer, err error) {
	err = d.call(func(c *client.Client) (err error) {
		var (
			rc   io.ReadCloser
			opts = types.ContainerLogsOptions{
				ShowStdout: true,
				ShowStderr: true,
				Tail:       strconv.Itoa(lines),
				Timestamps: timestamps,
				//Since: (time.Hour * 24).String()
			}
		)
		if rc, err = c.TaskLogs(ctx, id, opts); err == nil {
			defer rc.Close()

			stdout = &bytes.Buffer{}
			stderr = &bytes.Buffer{}
			_, err = stdcopy.StdCopy(stdout, stderr, rc)
		}
		return
	})
	return
}
